{"version":3,"file":"AxiosCsrfTokenService.js","names":["axios","getUrlParts","processAxiosErrorAndThrow","AxiosCsrfTokenService","csrfTokenApiPath","httpClient","create","defaults","withCredentials","headers","common","csrfTokenCache","csrfTokenRequestPromises","url","urlParts","e","global","location","origin","protocol","domain","csrfToken","get","then","response","data"],"sources":["../../src/auth/AxiosCsrfTokenService.js"],"sourcesContent":["import axios from 'axios';\nimport { getUrlParts, processAxiosErrorAndThrow } from './utils';\n\nexport default class AxiosCsrfTokenService {\n  constructor(csrfTokenApiPath) {\n    this.csrfTokenApiPath = csrfTokenApiPath;\n    this.httpClient = axios.create();\n    // Set withCredentials to true. Enables cross-site Access-Control requests\n    // to be made using cookies, authorization headers or TLS client\n    // certificates. More on MDN:\n    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials\n    this.httpClient.defaults.withCredentials = true;\n    this.httpClient.defaults.headers.common['USE-JWT-COOKIE'] = true;\n\n    this.csrfTokenCache = {};\n    this.csrfTokenRequestPromises = {};\n  }\n\n  async getCsrfToken(url) {\n    let urlParts;\n    try {\n      urlParts = getUrlParts(url);\n    } catch (e) {\n      // If the url is not parsable it's likely because a relative\n      // path was supplied as the url. This is acceptable and in\n      // this case we should use the current origin of the page.\n      urlParts = getUrlParts(global.location.origin);\n    }\n\n    const { protocol, domain } = urlParts;\n    const csrfToken = this.csrfTokenCache[domain];\n\n    if (csrfToken) {\n      return csrfToken;\n    }\n\n    if (!this.csrfTokenRequestPromises[domain]) {\n      this.csrfTokenRequestPromises[domain] = this.httpClient\n        .get(`${protocol}://${domain}${this.csrfTokenApiPath}`)\n        .then((response) => {\n          this.csrfTokenCache[domain] = response.data.csrfToken;\n          return this.csrfTokenCache[domain];\n        })\n        .catch(processAxiosErrorAndThrow)\n        .finally(() => {\n          delete this.csrfTokenRequestPromises[domain];\n        });\n    }\n\n    return this.csrfTokenRequestPromises[domain];\n  }\n\n  clearCsrfTokenCache() {\n    this.csrfTokenCache = {};\n  }\n\n  getHttpClient() {\n    return this.httpClient;\n  }\n}\n"],"mappings":";;;;;;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,WAAT,EAAsBC,yBAAtB,QAAuD,SAAvD;;IAEqBC,qB;EACnB,+BAAYC,gBAAZ,EAA8B;IAAA;;IAC5B,KAAKA,gBAAL,GAAwBA,gBAAxB;IACA,KAAKC,UAAL,GAAkBL,KAAK,CAACM,MAAN,EAAlB,CAF4B,CAG5B;IACA;IACA;IACA;;IACA,KAAKD,UAAL,CAAgBE,QAAhB,CAAyBC,eAAzB,GAA2C,IAA3C;IACA,KAAKH,UAAL,CAAgBE,QAAhB,CAAyBE,OAAzB,CAAiCC,MAAjC,CAAwC,gBAAxC,IAA4D,IAA5D;IAEA,KAAKC,cAAL,GAAsB,EAAtB;IACA,KAAKC,wBAAL,GAAgC,EAAhC;EACD;;;;;kFAED,iBAAmBC,GAAnB;QAAA;;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAEE,IAAI;kBACFC,QAAQ,GAAGb,WAAW,CAACY,GAAD,CAAtB;gBACD,CAFD,CAEE,OAAOE,CAAP,EAAU;kBACV;kBACA;kBACA;kBACAD,QAAQ,GAAGb,WAAW,CAACe,MAAM,CAACC,QAAP,CAAgBC,MAAjB,CAAtB;gBACD;;gBATH,YAW+BJ,QAX/B,EAWUK,QAXV,aAWUA,QAXV,EAWoBC,MAXpB,aAWoBA,MAXpB;gBAYQC,SAZR,GAYoB,KAAKV,cAAL,CAAoBS,MAApB,CAZpB;;gBAAA,KAcMC,SAdN;kBAAA;kBAAA;gBAAA;;gBAAA,iCAeWA,SAfX;;cAAA;gBAkBE,IAAI,CAAC,KAAKT,wBAAL,CAA8BQ,MAA9B,CAAL,EAA4C;kBAC1C,KAAKR,wBAAL,CAA8BQ,MAA9B,IAAwC,KAAKf,UAAL,CACrCiB,GADqC,WAC9BH,QAD8B,gBAChBC,MADgB,SACP,KAAKhB,gBADE,GAErCmB,IAFqC,CAEhC,UAACC,QAAD,EAAc;oBAClB,KAAI,CAACb,cAAL,CAAoBS,MAApB,IAA8BI,QAAQ,CAACC,IAAT,CAAcJ,SAA5C;oBACA,OAAO,KAAI,CAACV,cAAL,CAAoBS,MAApB,CAAP;kBACD,CALqC,WAM/BlB,yBAN+B,aAO7B,YAAM;oBACb,OAAO,KAAI,CAACU,wBAAL,CAA8BQ,MAA9B,CAAP;kBACD,CATqC,CAAxC;gBAUD;;gBA7BH,iCA+BS,KAAKR,wBAAL,CAA8BQ,MAA9B,CA/BT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;WAkCA,+BAAsB;MACpB,KAAKT,cAAL,GAAsB,EAAtB;IACD;;;WAED,yBAAgB;MACd,OAAO,KAAKN,UAAZ;IACD;;;;;;SAvDkBF,qB"}