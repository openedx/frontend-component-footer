import { placeInfoAtZero } from '../utils';
import { ANNOTATION_CLASS } from '../index';
var ref = {
  current: {
    style: {
      marginLeft: ''
    },
    children: [{
      className: "".concat(ANNOTATION_CLASS, " someClass"),
      getBoundingClientRect: function getBoundingClientRect() {
        return {
          width: 24.58123
        };
      }
    }, {
      className: 'anotherClass',
      getBoundingClientRect: function getBoundingClientRect() {
        return {
          width: 55.96844
        };
      }
    }]
  }
};
describe('utils', function () {
  describe('placeInfoAtZero', function () {
    it('changes left margin of the ref.current.style', function () {
      var previousValue = ref.current.style.marginLeft;
      placeInfoAtZero(ref);
      var changedValue = ref.current.style.marginLeft;
      expect(previousValue).not.toEqual(changedValue);
    });
    it('correctly calculates left margin when ref is passed', function () {
      placeInfoAtZero(ref);
      var children = ref.current.children;
      var marginLeft = 0.0;

      for (var i = 0; i < children.length || 0; i++) {
        var elementParams = children[i].getBoundingClientRect();

        if (children[i].className.includes(ANNOTATION_CLASS)) {
          marginLeft += elementParams.width / 2;
        } else {
          marginLeft += 0;
        }
      }

      var expectedMarginLeft = "".concat(-marginLeft, "px");
      var actualMarginLeft = ref.current.style.marginLeft;
      expect(actualMarginLeft).toEqual(expectedMarginLeft);
    });
    it('correctly calculates left margin when annotationOnly equals to true', function () {
      placeInfoAtZero(ref, false);
      var children = ref.current.children;
      var marginLeft = 0.0;

      for (var i = 0; i < children.length || 0; i++) {
        var elementParams = children[i].getBoundingClientRect();

        if (children[i].className.includes(ANNOTATION_CLASS)) {
          marginLeft += elementParams.width / 2;
        } else {
          marginLeft += elementParams.width;
        }
      }

      var expectedMarginLeft = "".concat(-marginLeft, "px");
      var actualMarginLeft = ref.current.style.marginLeft;
      expect(actualMarginLeft).toEqual(expectedMarginLeft);
    });
    it('returns false if reference is wrong', function () {
      var wrongRef1 = {};
      var wrongRef2 = {
        current: {}
      };
      expect(placeInfoAtZero(wrongRef1)).toEqual(false);
      expect(placeInfoAtZero(wrongRef2)).toEqual(false);
    });
    it('returns true if reference is wrong', function () {
      expect(placeInfoAtZero(ref)).toEqual(true);
    });
  });
});
//# sourceMappingURL=utils.test.js.map