(function() {
  // bazel-out/darwin-fastbuild/bin/packages/ecma402-abstract/lib/CanonicalizeLocaleList.js
  function CanonicalizeLocaleList(locales) {
    return Intl.getCanonicalLocales(locales);
  }

  // bazel-out/darwin-fastbuild/bin/packages/ecma402-abstract/lib/262.js
  function ToString(o) {
    if (typeof o === "symbol") {
      throw TypeError("Cannot convert a Symbol value to a string");
    }
    return String(o);
  }
  function ToObject(arg) {
    if (arg == null) {
      throw new TypeError("undefined/null cannot be converted to object");
    }
    return Object(arg);
  }
  function SameValue(x, y) {
    if (Object.is) {
      return Object.is(x, y);
    }
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    }
    return x !== x && y !== y;
  }
  function Type(x) {
    if (x === null) {
      return "Null";
    }
    if (typeof x === "undefined") {
      return "Undefined";
    }
    if (typeof x === "function" || typeof x === "object") {
      return "Object";
    }
    if (typeof x === "number") {
      return "Number";
    }
    if (typeof x === "boolean") {
      return "Boolean";
    }
    if (typeof x === "string") {
      return "String";
    }
    if (typeof x === "symbol") {
      return "Symbol";
    }
    if (typeof x === "bigint") {
      return "BigInt";
    }
  }
  var MINUTES_PER_HOUR = 60;
  var SECONDS_PER_MINUTE = 60;
  var MS_PER_SECOND = 1e3;
  var MS_PER_MINUTE = MS_PER_SECOND * SECONDS_PER_MINUTE;
  var MS_PER_HOUR = MS_PER_MINUTE * MINUTES_PER_HOUR;

  // bazel-out/darwin-fastbuild/bin/packages/ecma402-abstract/lib/CoerceOptionsToObject.js
  function CoerceOptionsToObject(options) {
    if (typeof options === "undefined") {
      return /* @__PURE__ */ Object.create(null);
    }
    return ToObject(options);
  }

  // bazel-out/darwin-fastbuild/bin/packages/ecma402-abstract/lib/GetOption.js
  function GetOption(opts, prop, type, values, fallback) {
    if (typeof opts !== "object") {
      throw new TypeError("Options must be an object");
    }
    var value = opts[prop];
    if (value !== void 0) {
      if (type !== "boolean" && type !== "string") {
        throw new TypeError("invalid type");
      }
      if (type === "boolean") {
        value = Boolean(value);
      }
      if (type === "string") {
        value = ToString(value);
      }
      if (values !== void 0 && !values.filter(function(val) {
        return val == value;
      }).length) {
        throw new RangeError("".concat(value, " is not within ").concat(values.join(", ")));
      }
      return value;
    }
    return fallback;
  }

  // bazel-out/darwin-fastbuild/bin/packages/ecma402-abstract/lib/utils.js
  function invariant(condition, message, Err) {
    if (Err === void 0) {
      Err = Error;
    }
    if (!condition) {
      throw new Err(message);
    }
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/abstract/CanonicalizeLocaleList.js
  function CanonicalizeLocaleList2(locales) {
    return Intl.getCanonicalLocales(locales);
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/abstract/utils.js
  var UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;
  function invariant2(condition, message, Err) {
    if (Err === void 0) {
      Err = Error;
    }
    if (!condition) {
      throw new Err(message);
    }
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/abstract/BestAvailableLocale.js
  function BestAvailableLocale(availableLocales, locale) {
    var candidate = locale;
    while (true) {
      if (availableLocales.has(candidate)) {
        return candidate;
      }
      var pos = candidate.lastIndexOf("-");
      if (!~pos) {
        return void 0;
      }
      if (pos >= 2 && candidate[pos - 2] === "-") {
        pos -= 2;
      }
      candidate = candidate.slice(0, pos);
    }
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/abstract/LookupMatcher.js
  function LookupMatcher(availableLocales, requestedLocales, getDefaultLocale) {
    var result = { locale: "" };
    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
      var locale = requestedLocales_1[_i];
      var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, "");
      var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
      if (availableLocale) {
        result.locale = availableLocale;
        if (locale !== noExtensionLocale) {
          result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
        }
        return result;
      }
    }
    result.locale = getDefaultLocale();
    return result;
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/abstract/BestFitMatcher.js
  function BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale) {
    var minimizedAvailableLocaleMap = {};
    var availableLocaleMap = {};
    var canonicalizedLocaleMap = {};
    var minimizedAvailableLocales = /* @__PURE__ */ new Set();
    availableLocales.forEach(function(locale2) {
      var minimizedLocale = new Intl.Locale(locale2).minimize().toString();
      var canonicalizedLocale = Intl.getCanonicalLocales(locale2)[0] || locale2;
      minimizedAvailableLocaleMap[minimizedLocale] = locale2;
      availableLocaleMap[locale2] = locale2;
      canonicalizedLocaleMap[canonicalizedLocale] = locale2;
      minimizedAvailableLocales.add(minimizedLocale);
      minimizedAvailableLocales.add(locale2);
      minimizedAvailableLocales.add(canonicalizedLocale);
    });
    var foundLocale;
    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
      var l = requestedLocales_1[_i];
      if (foundLocale) {
        break;
      }
      var noExtensionLocale = l.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, "");
      if (availableLocales.has(noExtensionLocale)) {
        foundLocale = noExtensionLocale;
        break;
      }
      if (minimizedAvailableLocales.has(noExtensionLocale)) {
        foundLocale = noExtensionLocale;
        break;
      }
      var locale = new Intl.Locale(noExtensionLocale);
      var maximizedRequestedLocale = locale.maximize().toString();
      var minimizedRequestedLocale = locale.minimize().toString();
      if (minimizedAvailableLocales.has(minimizedRequestedLocale)) {
        foundLocale = minimizedRequestedLocale;
        break;
      }
      foundLocale = BestAvailableLocale(minimizedAvailableLocales, maximizedRequestedLocale);
    }
    if (!foundLocale) {
      return { locale: getDefaultLocale() };
    }
    return {
      locale: availableLocaleMap[foundLocale] || canonicalizedLocaleMap[foundLocale] || minimizedAvailableLocaleMap[foundLocale] || foundLocale
    };
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/abstract/UnicodeExtensionValue.js
  function UnicodeExtensionValue(extension, key) {
    invariant2(key.length === 2, "key must have 2 elements");
    var size = extension.length;
    var searchValue = "-".concat(key, "-");
    var pos = extension.indexOf(searchValue);
    if (pos !== -1) {
      var start = pos + 4;
      var end = start;
      var k = start;
      var done = false;
      while (!done) {
        var e = extension.indexOf("-", k);
        var len = void 0;
        if (e === -1) {
          len = size - k;
        } else {
          len = e - k;
        }
        if (len === 2) {
          done = true;
        } else if (e === -1) {
          end = size;
          done = true;
        } else {
          end = e;
          k = e + 1;
        }
      }
      return extension.slice(start, end);
    }
    searchValue = "-".concat(key);
    pos = extension.indexOf(searchValue);
    if (pos !== -1 && pos + 3 === size) {
      return "";
    }
    return void 0;
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/abstract/ResolveLocale.js
  function ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData, getDefaultLocale) {
    var matcher = options.localeMatcher;
    var r;
    if (matcher === "lookup") {
      r = LookupMatcher(availableLocales, requestedLocales, getDefaultLocale);
    } else {
      r = BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale);
    }
    var foundLocale = r.locale;
    var result = { locale: "", dataLocale: foundLocale };
    var supportedExtension = "-u";
    for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {
      var key = relevantExtensionKeys_1[_i];
      invariant2(foundLocale in localeData, "Missing locale data for ".concat(foundLocale));
      var foundLocaleData = localeData[foundLocale];
      invariant2(typeof foundLocaleData === "object" && foundLocaleData !== null, "locale data ".concat(key, " must be an object"));
      var keyLocaleData = foundLocaleData[key];
      invariant2(Array.isArray(keyLocaleData), "keyLocaleData for ".concat(key, " must be an array"));
      var value = keyLocaleData[0];
      invariant2(typeof value === "string" || value === null, "value must be string or null but got ".concat(typeof value, " in key ").concat(key));
      var supportedExtensionAddition = "";
      if (r.extension) {
        var requestedValue = UnicodeExtensionValue(r.extension, key);
        if (requestedValue !== void 0) {
          if (requestedValue !== "") {
            if (~keyLocaleData.indexOf(requestedValue)) {
              value = requestedValue;
              supportedExtensionAddition = "-".concat(key, "-").concat(value);
            }
          } else if (~requestedValue.indexOf("true")) {
            value = "true";
            supportedExtensionAddition = "-".concat(key);
          }
        }
      }
      if (key in options) {
        var optionsValue = options[key];
        invariant2(typeof optionsValue === "string" || typeof optionsValue === "undefined" || optionsValue === null, "optionsValue must be String, Undefined or Null");
        if (~keyLocaleData.indexOf(optionsValue)) {
          if (optionsValue !== value) {
            value = optionsValue;
            supportedExtensionAddition = "";
          }
        }
      }
      result[key] = value;
      supportedExtension += supportedExtensionAddition;
    }
    if (supportedExtension.length > 2) {
      var privateIndex = foundLocale.indexOf("-x-");
      if (privateIndex === -1) {
        foundLocale = foundLocale + supportedExtension;
      } else {
        var preExtension = foundLocale.slice(0, privateIndex);
        var postExtension = foundLocale.slice(privateIndex, foundLocale.length);
        foundLocale = preExtension + supportedExtension + postExtension;
      }
      foundLocale = Intl.getCanonicalLocales(foundLocale)[0];
    }
    result.locale = foundLocale;
    return result;
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/abstract/LookupSupportedLocales.js
  function LookupSupportedLocales(availableLocales, requestedLocales) {
    var subset = [];
    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
      var locale = requestedLocales_1[_i];
      var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, "");
      var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
      if (availableLocale) {
        subset.push(availableLocale);
      }
    }
    return subset;
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-localematcher/lib/index.js
  function match(requestedLocales, availableLocales, defaultLocale, opts) {
    var locales = availableLocales.reduce(function(all, l) {
      all.add(l);
      return all;
    }, /* @__PURE__ */ new Set());
    return ResolveLocale(locales, CanonicalizeLocaleList2(requestedLocales), {
      localeMatcher: (opts === null || opts === void 0 ? void 0 : opts.algorithm) || "best fit"
    }, [], {}, function() {
      return defaultLocale;
    }).locale;
  }

  // bazel-out/darwin-fastbuild/bin/packages/ecma402-abstract/lib/PartitionPattern.js
  function PartitionPattern(pattern) {
    var result = [];
    var beginIndex = pattern.indexOf("{");
    var endIndex = 0;
    var nextIndex = 0;
    var length = pattern.length;
    while (beginIndex < pattern.length && beginIndex > -1) {
      endIndex = pattern.indexOf("}", beginIndex);
      invariant(endIndex > beginIndex, "Invalid pattern ".concat(pattern));
      if (beginIndex > nextIndex) {
        result.push({
          type: "literal",
          value: pattern.substring(nextIndex, beginIndex)
        });
      }
      result.push({
        type: pattern.substring(beginIndex + 1, endIndex),
        value: void 0
      });
      nextIndex = endIndex + 1;
      beginIndex = pattern.indexOf("{", nextIndex);
    }
    if (nextIndex < length) {
      result.push({
        type: "literal",
        value: pattern.substring(nextIndex, length)
      });
    }
    return result;
  }

  // bazel-out/darwin-fastbuild/bin/packages/ecma402-abstract/lib/SupportedLocales.js
  function SupportedLocales(availableLocales, requestedLocales, options) {
    var matcher = "best fit";
    if (options !== void 0) {
      options = ToObject(options);
      matcher = GetOption(options, "localeMatcher", "string", ["lookup", "best fit"], "best fit");
    }
    if (matcher === "best fit") {
      return LookupSupportedLocales(availableLocales, requestedLocales);
    }
    return LookupSupportedLocales(availableLocales, requestedLocales);
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/abstract/InitializeRelativeTimeFormat.js
  var NUMBERING_SYSTEM_REGEX = /^[a-z0-9]{3,8}(-[a-z0-9]{3,8})*$/i;
  function InitializeRelativeTimeFormat(rtf, locales, options, _a) {
    var getInternalSlots2 = _a.getInternalSlots, availableLocales = _a.availableLocales, relevantExtensionKeys = _a.relevantExtensionKeys, localeData = _a.localeData, getDefaultLocale = _a.getDefaultLocale;
    var internalSlots = getInternalSlots2(rtf);
    internalSlots.initializedRelativeTimeFormat = true;
    var requestedLocales = CanonicalizeLocaleList(locales);
    var opt = /* @__PURE__ */ Object.create(null);
    var opts = CoerceOptionsToObject(options);
    var matcher = GetOption(opts, "localeMatcher", "string", ["best fit", "lookup"], "best fit");
    opt.localeMatcher = matcher;
    var numberingSystem = GetOption(opts, "numberingSystem", "string", void 0, void 0);
    if (numberingSystem !== void 0) {
      if (!NUMBERING_SYSTEM_REGEX.test(numberingSystem)) {
        throw new RangeError("Invalid numbering system ".concat(numberingSystem));
      }
    }
    opt.nu = numberingSystem;
    var r = ResolveLocale(availableLocales, requestedLocales, opt, relevantExtensionKeys, localeData, getDefaultLocale);
    var locale = r.locale, nu = r.nu;
    internalSlots.locale = locale;
    internalSlots.style = GetOption(opts, "style", "string", ["long", "narrow", "short"], "long");
    internalSlots.numeric = GetOption(opts, "numeric", "string", ["always", "auto"], "always");
    var fields = localeData[r.dataLocale];
    invariant(!!fields, "Missing locale data for ".concat(r.dataLocale));
    internalSlots.fields = fields;
    internalSlots.numberFormat = new Intl.NumberFormat(locales);
    internalSlots.pluralRules = new Intl.PluralRules(locales);
    internalSlots.numberingSystem = nu;
    return rtf;
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/abstract/SingularRelativeTimeUnit.js
  function SingularRelativeTimeUnit(unit) {
    invariant(Type(unit) === "String", "unit must be a string");
    if (unit === "seconds")
      return "second";
    if (unit === "minutes")
      return "minute";
    if (unit === "hours")
      return "hour";
    if (unit === "days")
      return "day";
    if (unit === "weeks")
      return "week";
    if (unit === "months")
      return "month";
    if (unit === "quarters")
      return "quarter";
    if (unit === "years")
      return "year";
    if (unit !== "second" && unit !== "minute" && unit !== "hour" && unit !== "day" && unit !== "week" && unit !== "month" && unit !== "quarter" && unit !== "year") {
      throw new RangeError("invalid unit");
    }
    return unit;
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/abstract/MakePartsList.js
  function MakePartsList(pattern, unit, parts) {
    var patternParts = PartitionPattern(pattern);
    var result = [];
    for (var _i = 0, patternParts_1 = patternParts; _i < patternParts_1.length; _i++) {
      var patternPart = patternParts_1[_i];
      if (patternPart.type === "literal") {
        result.push({
          type: "literal",
          value: patternPart.value
        });
      } else {
        invariant(patternPart.type === "0", "Malformed pattern ".concat(pattern));
        for (var _a = 0, parts_1 = parts; _a < parts_1.length; _a++) {
          var part = parts_1[_a];
          result.push({
            type: part.type,
            value: part.value,
            unit: unit
          });
        }
      }
    }
    return result;
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/abstract/PartitionRelativeTimePattern.js
  function PartitionRelativeTimePattern(rtf, value, unit, _a) {
    var getInternalSlots2 = _a.getInternalSlots;
    invariant(Type(value) === "Number", "value must be number, instead got ".concat(typeof value), TypeError);
    invariant(Type(unit) === "String", "unit must be number, instead got ".concat(typeof value), TypeError);
    if (isNaN(value) || !isFinite(value)) {
      throw new RangeError("Invalid value ".concat(value));
    }
    var resolvedUnit = SingularRelativeTimeUnit(unit);
    var _b = getInternalSlots2(rtf), fields = _b.fields, style = _b.style, numeric = _b.numeric, pluralRules = _b.pluralRules, numberFormat = _b.numberFormat;
    var entry = resolvedUnit;
    if (style === "short") {
      entry = "".concat(resolvedUnit, "-short");
    } else if (style === "narrow") {
      entry = "".concat(resolvedUnit, "-narrow");
    }
    if (!(entry in fields)) {
      entry = resolvedUnit;
    }
    var patterns = fields[entry];
    if (numeric === "auto") {
      if (ToString(value) in patterns) {
        return [
          {
            type: "literal",
            value: patterns[ToString(value)]
          }
        ];
      }
    }
    var tl = "future";
    if (SameValue(value, -0) || value < 0) {
      tl = "past";
    }
    var po = patterns[tl];
    var fv = typeof numberFormat.formatToParts === "function" ? numberFormat.formatToParts(Math.abs(value)) : [
      {
        type: "literal",
        value: numberFormat.format(Math.abs(value)),
        unit: unit
      }
    ];
    var pr = pluralRules.select(value);
    var pattern = po[pr];
    return MakePartsList(pattern, resolvedUnit, fv);
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/get_internal_slots.js
  var internalSlotMap = /* @__PURE__ */ new WeakMap();
  function getInternalSlots(x) {
    var internalSlots = internalSlotMap.get(x);
    if (!internalSlots) {
      internalSlots = /* @__PURE__ */ Object.create(null);
      internalSlotMap.set(x, internalSlots);
    }
    return internalSlots;
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/index.js
  var RelativeTimeFormat = function() {
    function RelativeTimeFormat2(locales, options) {
      var newTarget = this && this instanceof RelativeTimeFormat2 ? this.constructor : void 0;
      if (!newTarget) {
        throw new TypeError("Intl.RelativeTimeFormat must be called with 'new'");
      }
      return InitializeRelativeTimeFormat(this, locales, options, {
        getInternalSlots: getInternalSlots,
        availableLocales: RelativeTimeFormat2.availableLocales,
        relevantExtensionKeys: RelativeTimeFormat2.relevantExtensionKeys,
        localeData: RelativeTimeFormat2.localeData,
        getDefaultLocale: RelativeTimeFormat2.getDefaultLocale
      });
    }
    RelativeTimeFormat2.prototype.format = function(value, unit) {
      if (typeof this !== "object") {
        throw new TypeError("format was called on a non-object");
      }
      var internalSlots = getInternalSlots(this);
      if (!internalSlots.initializedRelativeTimeFormat) {
        throw new TypeError("format was called on a invalid context");
      }
      return PartitionRelativeTimePattern(this, Number(value), ToString(unit), {
        getInternalSlots: getInternalSlots
      }).map(function(el) {
        return el.value;
      }).join("");
    };
    RelativeTimeFormat2.prototype.formatToParts = function(value, unit) {
      if (typeof this !== "object") {
        throw new TypeError("formatToParts was called on a non-object");
      }
      var internalSlots = getInternalSlots(this);
      if (!internalSlots.initializedRelativeTimeFormat) {
        throw new TypeError("formatToParts was called on a invalid context");
      }
      return PartitionRelativeTimePattern(this, Number(value), ToString(unit), { getInternalSlots: getInternalSlots });
    };
    RelativeTimeFormat2.prototype.resolvedOptions = function() {
      if (typeof this !== "object") {
        throw new TypeError("resolvedOptions was called on a non-object");
      }
      var internalSlots = getInternalSlots(this);
      if (!internalSlots.initializedRelativeTimeFormat) {
        throw new TypeError("resolvedOptions was called on a invalid context");
      }
      return {
        locale: internalSlots.locale,
        style: internalSlots.style,
        numeric: internalSlots.numeric,
        numberingSystem: internalSlots.numberingSystem
      };
    };
    RelativeTimeFormat2.supportedLocalesOf = function(locales, options) {
      return SupportedLocales(RelativeTimeFormat2.availableLocales, CanonicalizeLocaleList(locales), options);
    };
    RelativeTimeFormat2.__addLocaleData = function() {
      var data = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        data[_i] = arguments[_i];
      }
      for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
        var _b = data_1[_a], d = _b.data, locale = _b.locale;
        var minimizedLocale = new Intl.Locale(locale).minimize().toString();
        RelativeTimeFormat2.localeData[locale] = RelativeTimeFormat2.localeData[minimizedLocale] = d;
        RelativeTimeFormat2.availableLocales.add(minimizedLocale);
        RelativeTimeFormat2.availableLocales.add(locale);
        if (!RelativeTimeFormat2.__defaultLocale) {
          RelativeTimeFormat2.__defaultLocale = minimizedLocale;
        }
      }
    };
    RelativeTimeFormat2.getDefaultLocale = function() {
      return RelativeTimeFormat2.__defaultLocale;
    };
    RelativeTimeFormat2.localeData = {};
    RelativeTimeFormat2.availableLocales = /* @__PURE__ */ new Set();
    RelativeTimeFormat2.__defaultLocale = "";
    RelativeTimeFormat2.relevantExtensionKeys = ["nu"];
    RelativeTimeFormat2.polyfilled = true;
    return RelativeTimeFormat2;
  }();
  var lib_default = RelativeTimeFormat;
  try {
    if (typeof Symbol !== "undefined") {
      Object.defineProperty(RelativeTimeFormat.prototype, Symbol.toStringTag, {
        value: "Intl.RelativeTimeFormat",
        writable: false,
        enumerable: false,
        configurable: true
      });
    }
    Object.defineProperty(RelativeTimeFormat.prototype.constructor, "length", {
      value: 0,
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RelativeTimeFormat.supportedLocalesOf, "length", {
      value: 1,
      writable: false,
      enumerable: false,
      configurable: true
    });
  } catch (e) {
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/supported-locales.js
  var supportedLocales = ["af-NA", "af", "agq", "ak", "am", "ar-AE", "ar-BH", "ar-DJ", "ar-DZ", "ar-EG", "ar-EH", "ar-ER", "ar-IL", "ar-IQ", "ar-JO", "ar-KM", "ar-KW", "ar-LB", "ar-LY", "ar-MA", "ar-MR", "ar-OM", "ar-PS", "ar-QA", "ar-SA", "ar-SD", "ar-SO", "ar-SS", "ar-SY", "ar-TD", "ar-TN", "ar-YE", "ar", "as", "asa", "ast", "az-Cyrl", "az-Latn", "az", "bas", "be-tarask", "be", "bem", "bez", "bg", "bm", "bn-IN", "bn", "bo-IN", "bo", "br", "brx", "bs-Cyrl", "bs-Latn", "bs", "ca-AD", "ca-ES-valencia", "ca-FR", "ca-IT", "ca", "ccp-IN", "ccp", "ce", "ceb", "cgg", "chr", "ckb-IR", "ckb", "cs", "cy", "da-GL", "da", "dav", "de-AT", "de-BE", "de-CH", "de-IT", "de-LI", "de-LU", "de", "dje", "doi", "dsb", "dua", "dyo", "dz", "ebu", "ee-TG", "ee", "el-CY", "el", "en-001", "en-150", "en-AE", "en-AG", "en-AI", "en-AS", "en-AT", "en-AU", "en-BB", "en-BE", "en-BI", "en-BM", "en-BS", "en-BW", "en-BZ", "en-CA", "en-CC", "en-CH", "en-CK", "en-CM", "en-CX", "en-CY", "en-DE", "en-DG", "en-DK", "en-DM", "en-ER", "en-FI", "en-FJ", "en-FK", "en-FM", "en-GB", "en-GD", "en-GG", "en-GH", "en-GI", "en-GM", "en-GU", "en-GY", "en-HK", "en-IE", "en-IL", "en-IM", "en-IN", "en-IO", "en-JE", "en-JM", "en-KE", "en-KI", "en-KN", "en-KY", "en-LC", "en-LR", "en-LS", "en-MG", "en-MH", "en-MO", "en-MP", "en-MS", "en-MT", "en-MU", "en-MW", "en-MY", "en-NA", "en-NF", "en-NG", "en-NL", "en-NR", "en-NU", "en-NZ", "en-PG", "en-PH", "en-PK", "en-PN", "en-PR", "en-PW", "en-RW", "en-SB", "en-SC", "en-SD", "en-SE", "en-SG", "en-SH", "en-SI", "en-SL", "en-SS", "en-SX", "en-SZ", "en-TC", "en-TK", "en-TO", "en-TT", "en-TV", "en-TZ", "en-UG", "en-UM", "en-VC", "en-VG", "en-VI", "en-VU", "en-WS", "en-ZA", "en-ZM", "en-ZW", "en", "eo", "es-419", "es-AR", "es-BO", "es-BR", "es-BZ", "es-CL", "es-CO", "es-CR", "es-CU", "es-DO", "es-EA", "es-EC", "es-GQ", "es-GT", "es-HN", "es-IC", "es-MX", "es-NI", "es-PA", "es-PE", "es-PH", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE", "es", "et", "eu", "ewo", "fa-AF", "fa", "ff-Adlm-BF", "ff-Adlm-CM", "ff-Adlm-GH", "ff-Adlm-GM", "ff-Adlm-GW", "ff-Adlm-LR", "ff-Adlm-MR", "ff-Adlm-NE", "ff-Adlm-NG", "ff-Adlm-SL", "ff-Adlm-SN", "ff-Adlm", "ff-Latn-BF", "ff-Latn-CM", "ff-Latn-GH", "ff-Latn-GM", "ff-Latn-GN", "ff-Latn-GW", "ff-Latn-LR", "ff-Latn-MR", "ff-Latn-NE", "ff-Latn-NG", "ff-Latn-SL", "ff-Latn", "ff", "fi", "fil", "fo-DK", "fo", "fr-BE", "fr-BF", "fr-BI", "fr-BJ", "fr-BL", "fr-CA", "fr-CD", "fr-CF", "fr-CG", "fr-CH", "fr-CI", "fr-CM", "fr-DJ", "fr-DZ", "fr-GA", "fr-GF", "fr-GN", "fr-GP", "fr-GQ", "fr-HT", "fr-KM", "fr-LU", "fr-MA", "fr-MC", "fr-MF", "fr-MG", "fr-ML", "fr-MQ", "fr-MR", "fr-MU", "fr-NC", "fr-NE", "fr-PF", "fr-PM", "fr-RE", "fr-RW", "fr-SC", "fr-SN", "fr-SY", "fr-TD", "fr-TG", "fr-TN", "fr-VU", "fr-WF", "fr-YT", "fr", "fur", "fy", "ga-GB", "ga", "gd", "gl", "gsw-FR", "gsw-LI", "gsw", "gu", "guz", "gv", "ha-GH", "ha-NE", "ha", "haw", "he", "hi", "hr-BA", "hr", "hsb", "hu", "hy", "ia", "id", "ig", "ii", "is", "it-CH", "it-SM", "it-VA", "it", "ja", "jgo", "jmc", "jv", "ka", "kab", "kam", "kde", "kea", "kgp", "khq", "ki", "kk", "kkj", "kl", "kln", "km", "kn", "ko-KP", "ko", "kok", "ks-Arab", "ks", "ksb", "ksf", "ksh", "ku", "kw", "ky", "lag", "lb", "lg", "lkt", "ln-AO", "ln-CF", "ln-CG", "ln", "lo", "lrc-IQ", "lrc", "lt", "lu", "luo", "luy", "lv", "mai", "mas-TZ", "mas", "mer", "mfe", "mg", "mgh", "mgo", "mi", "mk", "ml", "mn", "mni-Beng", "mni", "mr", "ms-BN", "ms-ID", "ms-SG", "ms", "mt", "mua", "my", "mzn", "naq", "nb-SJ", "nb", "nd", "nds-NL", "nds", "ne-IN", "ne", "nl-AW", "nl-BE", "nl-BQ", "nl-CW", "nl-SR", "nl-SX", "nl", "nmg", "nn", "nnh", "no", "nus", "nyn", "om-KE", "om", "or", "os-RU", "os", "pa-Arab", "pa-Guru", "pa", "pcm", "pl", "ps-PK", "ps", "pt-AO", "pt-CH", "pt-CV", "pt-GQ", "pt-GW", "pt-LU", "pt-MO", "pt-MZ", "pt-PT", "pt-ST", "pt-TL", "pt", "qu-BO", "qu-EC", "qu", "rm", "rn", "ro-MD", "ro", "rof", "ru-BY", "ru-KG", "ru-KZ", "ru-MD", "ru-UA", "ru", "rw", "rwk", "sa", "sah", "saq", "sat-Olck", "sat", "sbp", "sc", "sd-Arab", "sd-Deva", "sd", "se-FI", "se-SE", "se", "seh", "ses", "sg", "shi-Latn", "shi-Tfng", "shi", "si", "sk", "sl", "smn", "sn", "so-DJ", "so-ET", "so-KE", "so", "sq-MK", "sq-XK", "sq", "sr-Cyrl-BA", "sr-Cyrl-ME", "sr-Cyrl-XK", "sr-Cyrl", "sr-Latn-BA", "sr-Latn-ME", "sr-Latn-XK", "sr-Latn", "sr", "su-Latn", "su", "sv-AX", "sv-FI", "sv", "sw-CD", "sw-KE", "sw-UG", "sw", "ta-LK", "ta-MY", "ta-SG", "ta", "te", "teo-KE", "teo", "tg", "th", "ti-ER", "ti", "tk", "to", "tr-CY", "tr", "tt", "twq", "tzm", "ug", "uk", "und", "ur-IN", "ur", "uz-Arab", "uz-Cyrl", "uz-Latn", "uz", "vai-Latn", "vai-Vaii", "vai", "vi", "vun", "wae", "wo", "xh", "xog", "yav", "yi", "yo-BJ", "yo", "yrl-CO", "yrl-VE", "yrl", "yue-Hans", "yue-Hant", "yue", "zgh", "zh-Hans-HK", "zh-Hans-MO", "zh-Hans-SG", "zh-Hans", "zh-Hant-HK", "zh-Hant-MO", "zh-Hant", "zh", "zu"];

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/should-polyfill.js
  function supportedLocalesOf(locale) {
    if (!locale) {
      return true;
    }
    var locales = Array.isArray(locale) ? locale : [locale];
    return Intl.RelativeTimeFormat.supportedLocalesOf(locales).length === locales.length;
  }
  function hasResolvedOptionsNumberingSystem(locale) {
    try {
      return "numberingSystem" in new Intl.RelativeTimeFormat(locale || "en", {
        numeric: "auto"
      }).resolvedOptions();
    } catch (_) {
      return false;
    }
  }
  function shouldPolyfill(locale) {
    if (locale === void 0) {
      locale = "en";
    }
    if (!("RelativeTimeFormat" in Intl) || !supportedLocalesOf(locale) || !hasResolvedOptionsNumberingSystem(locale)) {
      return match([locale], supportedLocales, "en");
    }
  }

  // bazel-out/darwin-fastbuild/bin/packages/intl-relativetimeformat/lib/polyfill.js
  if (shouldPolyfill()) {
    Object.defineProperty(Intl, "RelativeTimeFormat", {
      value: lib_default,
      writable: true,
      enumerable: false,
      configurable: true
    });
  }
})();
//# sourceMappingURL=polyfill.iife.js.map
